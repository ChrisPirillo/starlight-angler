<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <title>Starlight Angler - A Retro Arcade Space Fishing Game</title>
    <meta name="description" content="Hook stars, dodge asteroids, and beat the clock in Starlight Angler, a fast-paced, retro-pixel arcade game. Use your spaceship to cast a line into the cosmos and reel in valuable stars while managing your fuel.">
    <meta name="keywords" content="starlight angler, arcade game, retro game, pixel art, fishing game, space game, asteroids, indie game, browser game">
    <meta name="author" content="Chris Pirillo">
    <link rel="canonical" href="https://pirillo.com/arcade/starlight-angler.html">

    <meta property="og:title" content="Starlight Angler - A Retro Arcade Space Fishing Game">
    <meta property="og:description" content="Hook stars, dodge asteroids, and beat the clock in this fast-paced, retro-pixel arcade game.">
    <meta property="og:image" content="https://pirillo.com/arcade/images/starlight-angler.png">
    <meta property="og:url" content="https://pirillo.com/arcade/starlight-angler.html">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@ChrisPirillo">
    <meta name="twitter:title" content="Starlight Angler - A Retro Arcade Space Fishing Game">
    <meta name="twitter:description" content="Hook stars, dodge asteroids, and beat the clock in this fast-paced, retro-pixel arcade game.">
    <meta name="twitter:image" content="https://pirillo.com/arcade/images/starlight-angler.png">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://www.googletagmanager.com">

    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            background-color: #000;
            color: #fff;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        canvas {
            display: block;
            background-color: #00001a;
            touch-action: none;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .overlay {
            position: absolute;
            text-align: center;
            z-index: 10;
        }
        .mobile-controls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            display: none; /* Hidden by default */
            justify-content: space-between;
        }
        @media (hover: none) and (pointer: coarse) {
            .mobile-controls {
                display: flex;
            }
        }
        .mobile-controls button {
            border: 4px solid #fff;
        }
        #startScreen {
            padding: 2rem;
            background-color: rgba(0, 0, 0, 0.8);
            border: 4px solid #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #levelUpMessage {
            padding: 2rem;
            background-color: rgba(0, 0, 0, 0.8);
            border: 4px solid #00ffff;
        }
    </style>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1CQ4D3VQ3L');
    </script>

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "Starlight Angler",
      "url": "https://pirillo.com/arcade/starlight-angler.html",
      "author": {
        "@type": "Person",
        "name": "Chris Pirillo"
      },
      "image": "https://pirillo.com/arcade/images/starlight-angler.png",
      "description": "Hook stars, dodge asteroids, and beat the clock in Starlight Angler, a fast-paced, retro-pixel arcade game.",
      "gamePlatform": "WebBrowser",
      "applicationCategory": "Game",
      "operatingSystem": "All",
      "inLanguage": "en-US",
      "playMode": "SinglePlayer",
      "keywords": "arcade, retro, pixel art, fishing, space, asteroids, browser game"
    }
    </script>
</head>
<body>

    <main id="game-container">
        <canvas id="gameCanvas"></canvas> 
        
        <div id="mobile-controls" class="overlay mobile-controls">
            <button id="leftBtn" class="p-4 bg-cyan-700 text-white active:bg-cyan-900">LEFT</button>
            <button id="castBtn" class="p-4 bg-green-700 text-white active:bg-green-900">CAST</button>
            <button id="rightBtn" class="p-4 bg-cyan-700 text-white active:bg-cyan-900">RIGHT</button>
        </div>

        <div id="startScreen" class="overlay">
            <h1 id="screenTitle" class="text-4xl mb-4 text-cyan-400">Starlight Angler</h1>
            <div id="screenContent">
                <p class="mb-6">Hook stars, dodge asteroids, and beat the clock!</p>
                <p class="mb-2">Controls:</p>
                <p class="mb-2">LEFT/RIGHT Arrows to move.</p>
                <p class="mb-6">SPACE to cast/reel.</p>
            </div>
            <button id="startButton" class="px-8 py-4 bg-green-700 text-white border-4 border-white hover:bg-green-600 transition">Start Fishing</button>
        </div>

        <div id="levelUpMessage" class="overlay hidden">
            <h2 class="text-3xl text-cyan-400">LEVEL UP!</h2>
        </div>
    </main>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- MODIFICATION: Removed all logical resolution and scaling variables. ---
        // The game world is now the size of the canvas itself.

        // UI Elements
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const levelUpMessage = document.getElementById('levelUpMessage');
        const screenTitle = document.getElementById('screenTitle');
        const screenContent = document.getElementById('screenContent');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const castBtn = document.getElementById('castBtn');

        let score = 0;
        let fuel = 100;
        let level = 1;
        let fuelInterval;
        let gameState = 'start'; 

        // Game settings
        const targetScore = 1000;
        const fuelDrainRate = 1000;
        // --- MODIFICATION: Increased PIXEL_SCALE to make all game elements larger. ---
        const PIXEL_SCALE = 8;

        // Game Objects
        let playerShip, hook, stars, obstacles, backgroundStars;

        // --- MODIFICATION: resizeGame now simply sets the canvas to the window size. ---
        function resizeGame() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }


        // --- Player (Ship) ---
        const playerShipObj = {
            x: 0,
            y: 60,
            width: 12 * PIXEL_SCALE,
            height: 6 * PIXEL_SCALE,
            speed: 8,
            dx: 0,
            draw() {
                const shipPixels = [
                    "  CCCCCC  ",
                    " CCCCCCCC ",
                    "CCFFFFFFCC",
                    "CCCCCCCCCC",
                    "C C    C C",
                    " CC    CC "
                ];
                ctx.save();
                ctx.translate(this.x + (this.width - shipPixels[0].length * PIXEL_SCALE) / 2, this.y);
                for (let r = 0; r < shipPixels.length; r++) {
                    for (let c = 0; c < shipPixels[r].length; c++) {
                        const pixel = shipPixels[r][c];
                        if (pixel === 'C') {
                            ctx.fillStyle = '#c0c0c0'; // Silver
                            ctx.fillRect(c * PIXEL_SCALE, r * PIXEL_SCALE, PIXEL_SCALE, PIXEL_SCALE);
                        } else if (pixel === 'F') {
                            ctx.fillStyle = '#00ffff'; // Cyan cockpit
                            ctx.fillRect(c * PIXEL_SCALE, r * PIXEL_SCALE, PIXEL_SCALE, PIXEL_SCALE);
                        }
                    }
                }
                ctx.restore();
            },
            update() {
                this.x += this.dx;
                if (this.x < 0) this.x = 0;
                // MODIFICATION: Use canvas.width for boundary checks
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
            }
        };

        // --- Hook ---
        const hookObj = {
            x: 0, y: 0, size: 3 * PIXEL_SCALE, speed: 5, dy: 0,
            isCast: false, isReeling: false, hookedStar: null,
            draw() {
                if (!this.isCast) return;
                ctx.fillStyle = '#c0c0c0';
                const startX = playerShipObj.x + playerShipObj.width / 2;
                const startY = playerShipObj.y + playerShipObj.height;
                const endX = this.x;
                const endY = this.y;
                
                const dx = endX - startX;
                const dy = endY - startY;
                const steps = Math.max(Math.abs(dx), Math.abs(dy)) / PIXEL_SCALE;
                
                for (let i = 0; i < steps; i++) {
                    const t = i / steps;
                    const px = startX + dx * t;
                    const py = startY + dy * t;
                    ctx.fillRect(Math.round(px / PIXEL_SCALE) * PIXEL_SCALE, Math.round(py / PIXEL_SCALE) * PIXEL_SCALE, PIXEL_SCALE, PIXEL_SCALE);
                }

                ctx.fillRect(this.x - this.size / 2, this.y, this.size, PIXEL_SCALE);
                ctx.fillRect(this.x - this.size / 2, this.y + PIXEL_SCALE, PIXEL_SCALE, PIXEL_SCALE * 2);
                ctx.fillRect(this.x + this.size / 2 - PIXEL_SCALE, this.y + PIXEL_SCALE, PIXEL_SCALE, PIXEL_SCALE * 2);
            },
            update() {
                if (!this.isCast) {
                    this.x = playerShipObj.x + playerShipObj.width / 2;
                    this.y = playerShipObj.y + playerShipObj.height;
                    return;
                }
                this.y += this.dy;
                if (!this.isReeling) this.x += playerShipObj.dx;
                if (this.hookedStar && this.hookedStar.struggle) this.x += this.hookedStar.struggleDirection * this.hookedStar.struggle;
                if (this.x < 0) this.x = 0;
                // MODIFICATION: Use canvas.width/height for boundary checks
                if (this.x > canvas.width) this.x = canvas.width;
                if (this.y > canvas.height) this.startReeling();
                if (this.isReeling && this.y <= playerShipObj.y + playerShipObj.height) {
                    if (this.hookedStar) {
                        score += this.hookedStar.points;
                        this.hookedStar = null;
                    }
                    this.reset();
                    updateUI();
                }
            },
            cast() { if (!this.isCast) { this.isCast = true; this.isReeling = false; this.dy = this.speed; }},
            startReeling() { this.isReeling = true; this.dy = -this.speed; },
            reset() { this.isCast = false; this.isReeling = false; this.hookedStar = null; this.dy = 0; }
        };

        // --- Star and Obstacle classes ---
        class Star {
            constructor(x, y, type, speedMultiplier) {
                this.x = x; this.y = y; this.type = type;
                this.size = 2 * PIXEL_SCALE;
                this.dx = (Math.random() - 0.5) * 2 * speedMultiplier;
                this.alpha = 1; this.alphaChange = -0.05;
                this.pulseSize = 0; this.pulseChange = 0.2;
                this.hue = Math.random() * 360;
                 switch (type) {
                    case 'flickering': this.points = 20; this.color = '#ffff00'; break;
                    case 'pulsing': this.points = 30; this.color = '#ff00ff'; this.struggle = 1 * speedMultiplier; this.struggleDirection = Math.random() < 0.5 ? 1 : -1; break;
                    case 'shifting': this.points = 50; this.color = `hsl(${this.hue}, 100%, 50%)`; this.struggle = 1.5 * speedMultiplier; this.struggleDirection = Math.random() < 0.5 ? 1 : -1; break;
                    default: this.points = 10; this.color = '#ffffff'; break;
                }
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.type === 'flickering' ? this.alpha : 1;
                ctx.fillStyle = this.color;
                let s = this.size + (this.type === 'pulsing' ? this.pulseSize : 0);
                ctx.fillRect(this.x - s/2, this.y - PIXEL_SCALE/2, s, PIXEL_SCALE);
                ctx.fillRect(this.x - PIXEL_SCALE/2, this.y - s/2, PIXEL_SCALE, s);
                ctx.restore();
            }
            update() {
                this.x += this.dx;
                // MODIFICATION: Use canvas.width for boundary checks
                if (this.x < 0 || this.x > canvas.width) this.dx *= -1;
                if (this.type === 'flickering') {
                    this.alpha += this.alphaChange;
                    if (this.alpha <= 0.2 || this.alpha >= 1) this.alphaChange *= -1;
                } else if (this.type === 'pulsing') {
                    this.pulseSize += this.pulseChange;
                    if (this.pulseSize <= 0 || this.pulseSize >= PIXEL_SCALE * 2) this.pulseChange *= -1;
                } else if (this.type === 'shifting') {
                    this.hue = (this.hue + 1) % 360;
                    this.color = `hsl(${this.hue}, 100%, 50%)`;
                }
            }
        }
        class Obstacle {
             constructor(x, y, speedMultiplier) {
                this.x = x; this.y = y;
                this.size = (Math.random() * 6 + 5) * PIXEL_SCALE;
                this.dx = (Math.random() - 0.5) * 1.5 * speedMultiplier;
                this.dy = (Math.random() - 0.5) * 1.5 * speedMultiplier;
                this.pattern = [];
                const patternSize = Math.floor(this.size / PIXEL_SCALE);
                for (let i = 0; i < patternSize; i++) {
                    this.pattern[i] = [];
                    for (let j = 0; j < patternSize; j++) {
                        const dist = Math.sqrt(Math.pow(i - patternSize/2, 2) + Math.pow(j - patternSize/2, 2));
                        if (dist < patternSize / 2 && Math.random() > 0.2) {
                            this.pattern[i][j] = Math.random() > 0.3 ? '#A9A9A9' : '#696969';
                        } else {
                            this.pattern[i][j] = 0;
                        }
                    }
                }
            }
            draw() {
                const patternSize = this.pattern.length;
                for (let i = 0; i < patternSize; i++) {
                    for (let j = 0; j < patternSize; j++) {
                        if (this.pattern[i][j]) {
                            ctx.fillStyle = this.pattern[i][j];
                            ctx.fillRect(this.x - this.size/2 + j * PIXEL_SCALE, this.y - this.size/2 + i * PIXEL_SCALE, PIXEL_SCALE, PIXEL_SCALE);
                        }
                    }
                }
            }
            update() {
                this.x += this.dx; this.y += this.dy;
                // MODIFICATION: Use canvas.width/height for boundary checks
                if (this.x - this.size/2 < 0 || this.x + this.size/2 > canvas.width) this.dx *= -1;
                if (this.y - this.size/2 < 80 || this.y + this.size/2 > canvas.height) this.dy *= -1;
            }
        }

        // --- Game Logic ---
        function init() {
            resizeGame(); 
            playerShip = playerShipObj;
            hook = hookObj;
            playerShip.x = canvas.width / 2 - playerShip.width / 2;
            hook.reset();
            backgroundStars = [];
            for (let i = 0; i < 200; i++) {
                // MODIFICATION: Use canvas.width/height for spawning
                backgroundStars.push({
                    x: Math.random() * canvas.width, y: Math.random() * canvas.height,
                    size: Math.random() * 2, alpha: Math.random() * 0.5 + 0.2,
                    alphaChange: Math.random() * 0.02 - 0.01
                });
            }
            spawnObjects(level);
        }
        
        function spawnObjects(currentLevel) {
            stars = [];
            obstacles = [];
            const starTypes = ['normal', 'flickering', 'pulsing', 'shifting'];
            const speedMultiplier = 1 + (currentLevel - 1) * 0.3;

            for (let i = 0; i < 15; i++) {
                // MODIFICATION: Use canvas.width/height for spawning
                stars.push(new Star(
                    Math.random() * canvas.width, Math.random() * (canvas.height - 250) + 200,
                    starTypes[Math.floor(Math.random() * starTypes.length)], speedMultiplier
                ));
            }
            for (let i = 0; i < 5 + (currentLevel * 2); i++) {
                // MODIFICATION: Use canvas.width/height for spawning
                obstacles.push(new Obstacle(
                    Math.random() * canvas.width, Math.random() * (canvas.height - 250) + 200,
                    speedMultiplier
                ));
            }
        }
        
        function nextLevel() {
            gameState = 'levelUp';
            level++;
            fuel = Math.min(100, fuel + 25);
            levelUpMessage.classList.remove('hidden');
            setTimeout(() => {
                levelUpMessage.classList.add('hidden');
                spawnObjects(level);
                gameState = 'playing';
                gameLoop();
            }, 2000);
        }

        function updateUI() {
            if (score >= targetScore) {
                endGame(true);
            }
        }

        function drawUI() {
            ctx.font = '16px "Press Start 2P"';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'left';
            ctx.fillText(`SCORE: ${score}`, 20, 35);
            ctx.textAlign = 'center';
            // MODIFICATION: Use canvas.width for UI positioning
            ctx.fillText(`LEVEL: ${level}`, canvas.width / 2, 35);
            ctx.textAlign = 'right';
            ctx.fillText(`FUEL: ${Math.max(0, fuel)}`, canvas.width - 20, 35);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, 50);
            ctx.lineTo(canvas.width, 50);
            ctx.stroke();
        }
        
        function drawStarfield() {
            ctx.fillStyle = '#FFFFFF';
            backgroundStars.forEach(s => {
                s.alpha += s.alphaChange;
                if (s.alpha <= 0.1 || s.alpha >= 0.7) s.alphaChange *= -1;
                ctx.globalAlpha = s.alpha;
                ctx.fillRect(s.x, s.y, s.size, s.size);
            });
            ctx.globalAlpha = 1;
        }

        function gameLoop() {
            if (gameState !== 'playing') return;

            // MODIFICATION: Simplified drawing loop, no more scaling transforms needed.
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawStarfield();
            playerShip.update();
            playerShip.draw();
            hook.update();
            hook.draw();
            stars.forEach(star => { star.update(); star.draw(); });
            obstacles.forEach(obstacle => { obstacle.update(); obstacle.draw(); });
            checkCollisions();
            drawUI();
            
            if (stars.length === 0 && !hook.isCast) {
                nextLevel();
            } else {
                requestAnimationFrame(gameLoop);
            }
        }
        
        function checkCollisions() {
            if (hook.isCast && !hook.hookedStar) {
                stars.forEach((star, index) => {
                    const dist = Math.hypot(hook.x - star.x, hook.y - star.y);
                    if (dist < hook.size + star.size) {
                        hook.hookedStar = star;
                        stars.splice(index, 1);
                        hook.startReeling();
                    }
                });
            }
            if (hook.isCast) {
                obstacles.forEach(obstacle => {
                    const lineStart = { x: playerShip.x + playerShip.width / 2, y: playerShip.y + playerShip.height };
                    const lineEnd = { x: hook.x, y: hook.y };
                    const circle = { x: obstacle.x, y: obstacle.y, radius: obstacle.size / 2 };
                    if (lineIntersectsCircle(lineStart, lineEnd, circle)) {
                        if (hook.hookedStar) hook.hookedStar = null;
                        hook.startReeling();
                    }
                });
            }
        }
        
        function lineIntersectsCircle(p1, p2, circle) {
            const dx = p2.x - p1.x; const dy = p2.y - p1.y;
            const a = dx * dx + dy * dy;
            const b = 2 * (dx * (p1.x - circle.x) + dy * (p1.y - circle.y));
            const c = (p1.x - circle.x) * (p1.x - circle.x) + (p1.y - circle.y) * (p1.y - circle.y) - circle.radius * circle.radius;
            let det = b * b - 4 * a * c;
            if (det < 0) return false;
            det = Math.sqrt(det);
            const t1 = (-b - det) / (2 * a); const t2 = (-b + det) / (2 * a);
            return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
        }

        function startGame() {
            gameState = 'playing';
            startScreen.style.display = 'none';
            score = 0; fuel = 100; level = 1;
            init();
            if (fuelInterval) clearInterval(fuelInterval);
            fuelInterval = setInterval(() => {
                if (gameState === 'playing') {
                    fuel--;
                    if (fuel <= 0) endGame(false);
                }
            }, fuelDrainRate);
            gameLoop();
        }

        function endGame(isWin) {
            gameState = 'gameOver';
            clearInterval(fuelInterval);
            startScreen.style.display = 'flex';
            
            if (isWin) {
                screenTitle.textContent = 'You Win!';
                screenContent.innerHTML = `<p class="mb-4">Target score reached!</p><p>Final Score: ${score}</p><p>Final Level: ${level}</p>`;
            } else {
                screenTitle.textContent = 'Game Over';
                screenContent.innerHTML = `<p class="mb-4">You ran out of fuel!</p><p>Final Score: ${score}</p>`;
            }
            startButton.textContent = 'Play Again';
        }

        // --- Controls ---
        function move(direction) {
            if (direction === 'left') playerShip.dx = -playerShip.speed;
            else if (direction === 'right') playerShip.dx = playerShip.speed;
        }
        function stopMove() { playerShip.dx = 0; }
        function handleCast() {
            if (gameState !== 'playing') return;
            if (hook.isCast && !hook.isReeling) hook.startReeling();
            else hook.cast();
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') move('left');
            if (e.key === 'ArrowRight') move('right');
            if (e.code === 'Space') handleCast();
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') stopMove();
        });
        leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); move('left'); });
        leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopMove(); });
        rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); move('right'); });
        rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopMove(); });
        castBtn.addEventListener('touchstart', (e) => { e.preventDefault(); handleCast(); });
        startButton.addEventListener('click', startGame);
        
        // --- MODIFICATION: Resizing the window will now re-initialize the game to fit the new dimensions.
        window.addEventListener('resize', init);

        window.onload = () => {
            init();
        };
    </script>
</body>
</html>
